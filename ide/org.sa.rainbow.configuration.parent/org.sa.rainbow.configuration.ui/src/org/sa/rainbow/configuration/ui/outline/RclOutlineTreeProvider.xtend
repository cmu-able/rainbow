/*
 * generated by Xtext 2.19.0
 */
package org.sa.rainbow.configuration.ui.outline

/*
 * Copyright 2020 Carnegie Mellon University

 * Permission is hereby granted, free of charge, to any person obtaining a copy of this 
 * software and associated documentation files (the "Software"), to deal in the Software 
 * without restriction, including without limitation the rights to use, copy, modify, merge,
 *  publish, distribute, sublicense, and/or sell copies of the Software, and to permit 
 *  persons to whom the Software is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all 
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */

import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.common.types.JvmType
import org.eclipse.xtext.ui.editor.outline.IOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.sa.rainbow.configuration.rcl.Assignment
import org.sa.rainbow.configuration.rcl.CommandCall
import org.sa.rainbow.configuration.rcl.CommandReference
import org.sa.rainbow.configuration.rcl.Component
import org.sa.rainbow.configuration.rcl.EffectorBody
import org.sa.rainbow.configuration.rcl.Factory
import org.sa.rainbow.configuration.rcl.GaugeBody
import org.sa.rainbow.configuration.rcl.GaugeTypeBody
import org.sa.rainbow.configuration.rcl.Probe
import org.sa.rainbow.configuration.rcl.PropertyReference
import org.sa.rainbow.configuration.rcl.RclPackage
import org.sa.rainbow.configuration.rcl.Reference

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
class RclOutlineTreeProvider extends DefaultOutlineTreeProvider {

	def Image nullImage() {
		return null;
	}

	def _createChildren(IOutlineNode parentNode, Component setup) {
		for (Assignment a : setup.assignment) {
			createNode(parentNode, a);
		}
	}

	def _createChildren(IOutlineNode parentNode, Assignment ass) {
		if (ass.value !== null && ass.value.value !== null && ass.value.value instanceof Component) {
			for (Assignment a : (ass.value.value as Component).assignment) {
				createNode(parentNode, a)
			}
		} else
			super._createChildren(parentNode, ass);
	}

	def _createNode(IOutlineNode parentNode, GaugeTypeBody gtb) {

		var model = ""
		val mcf = gtb.mcf
		if (mcf instanceof Reference) {
			if (mcf.referable instanceof JvmType) {
				model = '''...«(mcf.referable as JvmType).simpleName»'''
			} else if (mcf.referable instanceof Factory) {
				model = '''...«(mcf.referable as Factory).name»'''
			}
		} if (mcf instanceof PropertyReference) {
			if (mcf.referable instanceof Factory) {
				model = '''...«(mcf.referable as Factory).name»'''
			}
		} else
			createEObjectNode(parentNode, gtb.eContainer, nullImage(), model, true)
		for (cmd : gtb.commands) {
			super._createNode(parentNode, cmd)
		}
		for (ass : gtb.assignment) {
			super._createNode(parentNode, ass)
		}
	}

	def _CreateNode(IOutlineNode parentNode, GaugeBody gtb) {
		var model = ""
		var EStructuralFeature ref = null
		if (gtb.modelName != null || gtb.modeltype != null) {
			model = '''«gtb.modelName===null?"":gtb.modelName»::«gtb.modeltype!=null?"":gtb.modeltype»'''
			ref = RclPackage.Literals.GAUGE_BODY__MODEL_NAME
		} else if (gtb.ref?.referable != null) {
			model = '''«gtb.ref.referable.name»'''
			ref = RclPackage.Literals.GAUGE_BODY__REF
		}
		if (ref !== null) {
			createEStructuralFeatureNode(parentNode, gtb.eContainer, ref, nullImage(), model, true)
		} else {
			createEObjectNode(parentNode, gtb.eContainer, nullImage, model, true)
		}
		for (cmd : gtb.commands) {
			super._createNode(parentNode, cmd)
		}
		for (ass : gtb.assignment) {
			super._createNode(parentNode, ass)
		}
	}

	def _createNode(IOutlineNode parentNode, Probe probe) {
		for (ass : probe?.properties?.assignment) {
			super._createNode(parentNode, ass)
		}
	}

	def _createNode(IOutlineNode parentNode, EffectorBody body) {
		var model = ""
		var EStructuralFeature ref = null
		if (body.modelName != null || body.modeltype != null) {
			model = '''«body.modelName===null?"":body.modelName»::«body.modeltype!=null?"":body.modeltype»'''
			ref = RclPackage.Literals.EFFECTOR_BODY__MODEL_NAME
		} else if (body.ref?.referable != null) {
			model = '''«body.ref.referable.name»'''
			ref = RclPackage.Literals.EFFECTOR_BODY__REF
		}
		if (ref !== null)
			createEStructuralFeatureNode(parentNode, body, ref, nullImage(), model, true)
		else
			createEObjectNode(parentNode, body.eContainer, nullImage, model, true)
		for (ass : body.assignment) {
			super._createNode(parentNode, ass)
		}
	}

	def _createNode(IOutlineNode parentNode, CommandReference cr) {
		createEStructuralFeatureNode(parentNode, cr, RclPackage.Literals.COMMAND_REFERENCE__NAME, nullImage(), cr.name,
			true)
	}

	def _createNode(IOutlineNode parentNode, CommandCall cr) {
		createEStructuralFeatureNode(parentNode, cr, RclPackage.Literals.COMMAND_CALL__NAME, nullImage(), cr.name, true)
	}

	def _createNode(IOutlineNode parentNode, Assignment ass) {
		if (ass.value !== null && ass.value.value !== null && ass.value.value instanceof Component) {
			super._createNode(parentNode, ass);

		} else {
			createEStructuralFeatureNode(parentNode, ass, RclPackage.Literals.ASSIGNMENT__NAME, nullImage(), ass.name,
				true);
		}
	}

//	def _createChildren(IOutlineNode parentNode, Value v) {
//		var value = v.value;
//		if (value instanceof Component) {
//			var comp = value as Component;
//			for (Assignment a : comp.assignment) {
//				createNode(parentNode, a)
//			}
//		}
//		else {
//			super._createChildren(parentNode,v);
//		}
//		
//	}
}
