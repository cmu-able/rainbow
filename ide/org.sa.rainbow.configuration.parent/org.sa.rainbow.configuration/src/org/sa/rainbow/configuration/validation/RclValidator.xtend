/*
 * generated by Xtext 2.19.0
 */
package org.sa.rainbow.configuration.validation

/*
 * Copyright 2020 Carnegie Mellon University

 * Permission is hereby granted, free of charge, to any person obtaining a copy of this 
 * software and associated documentation files (the "Software"), to deal in the Software 
 * without restriction, including without limitation the rights to use, copy, modify, merge,
 *  publish, distribute, sublicense, and/or sell copies of the Software, and to permit 
 *  persons to whom the Software is furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all 
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 */

import com.google.inject.Inject
import com.google.inject.name.Named
import java.util.HashSet
import java.util.LinkedList
import java.util.List
import java.util.Map
import java.util.Set
import java.util.regex.Pattern
import java.util.regex.PatternSyntaxException
import java.util.stream.Collectors
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.JvmType
import org.eclipse.xtext.common.types.access.IJvmTypeProvider
import org.eclipse.xtext.common.types.util.Primitives
import org.eclipse.xtext.common.types.util.RawSuperTypes
import org.eclipse.xtext.util.Triple
import org.eclipse.xtext.util.Tuples
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.lib.Functions.Function1
import org.sa.rainbow.configuration.ConfigAttributeConstants
import org.sa.rainbow.configuration.ModelUtil
import org.sa.rainbow.configuration.Utils
import org.sa.rainbow.configuration.XtendUtils
import org.sa.rainbow.configuration.rcl.Array
import org.sa.rainbow.configuration.rcl.Assignment
import org.sa.rainbow.configuration.rcl.BooleanLiteral
import org.sa.rainbow.configuration.rcl.CommandCall
import org.sa.rainbow.configuration.rcl.CommandDefinition
import org.sa.rainbow.configuration.rcl.CommandReference
import org.sa.rainbow.configuration.rcl.Component
import org.sa.rainbow.configuration.rcl.ComponentType
import org.sa.rainbow.configuration.rcl.DeclaredProperty
import org.sa.rainbow.configuration.rcl.DoubleLiteral
import org.sa.rainbow.configuration.rcl.Effector
import org.sa.rainbow.configuration.rcl.Factory
import org.sa.rainbow.configuration.rcl.FactoryDefinition
import org.sa.rainbow.configuration.rcl.Gauge
import org.sa.rainbow.configuration.rcl.GaugeBody
import org.sa.rainbow.configuration.rcl.GaugeTypeBody
import org.sa.rainbow.configuration.rcl.IPLiteral
import org.sa.rainbow.configuration.rcl.ImpactVector
import org.sa.rainbow.configuration.rcl.Import
import org.sa.rainbow.configuration.rcl.IntegerLiteral
import org.sa.rainbow.configuration.rcl.JavaClassOrFactory
import org.sa.rainbow.configuration.rcl.Probe
import org.sa.rainbow.configuration.rcl.PropertyReference
import org.sa.rainbow.configuration.rcl.RclPackage
import org.sa.rainbow.configuration.rcl.Reference
import org.sa.rainbow.configuration.rcl.StringLiteral
import org.sa.rainbow.configuration.rcl.Value
import org.sa.rainbow.core.models.IModelInstance
import org.sa.rainbow.core.models.commands.AbstractLoadModelCmd
import org.sa.rainbow.core.models.commands.AbstractRainbowModelOperation
import org.sa.rainbow.core.models.commands.AbstractSaveModelCmd
import org.sa.rainbow.core.models.commands.ModelCommandFactory

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RclValidator extends AbstractRclValidator {

	public static val ONLY_EXTEND_PROBE_TYPES_MSG = "A probe can only extend a probe type"
	public static val ONLY_EXTEND_PROBE_TYPES = "invalidProbeType"
	public static val ONLY_EXTEND_EFFECTOR_TYPES = "invalidEffectorType"
	public static val MUST_SUBCLASS = "wrongtype"
	public static val MISSING_PROPERTY = "missingRequiredProperty"
	public static val COMMAND_NOT_IN_GAUGE_TYPE = "commandNotnGaugeSuperType"
	public static val NOT_VALID_GAUGE_COMMAND = "gaugeCommandNotValid"
	

	@Check
	def checkOnlyProbeAsSupertype(Probe probe) {
		var st = probe.superType
		if (st !== null) {
			if (!st.type) {
				val v = probe.eResource.resourceSet.resources
				val probeTypes = newHashSet
				for (r : v) {
					val res = r.allContents
					res.forEach[
						if (it instanceof Probe && (it as Probe).type) {
							probeTypes.add(it)
						}
					]
				}
				error(
					ONLY_EXTEND_PROBE_TYPES_MSG,
					RclPackage.Literals.PROBE__SUPER_TYPE,
					ONLY_EXTEND_PROBE_TYPES,
					probeTypes.join(","),
					"probe type"
				)
			}
		}

	}

	@Check
	def checkProbeContainsRequiredAttributes(Probe probe) {
		if (!probe.type) {
			checkAttributes(
				probe?.properties?.assignment,
				probe.superType?.properties?.assignment,
				ConfigAttributeConstants.ALL_OFREQUIRED_PROBE_FIELDS,
				ConfigAttributeConstants.ONE_OFREQUIRED_PROBE_FIELDS,
				RclPackage.Literals.PROBE__PROPERTIES
			);
		}
		for (Assignment a : probe.properties?.assignment) {
			checkAssignmentType(a, ConfigAttributeConstants.PROBE_PROPERTY_TYPES, "")

		}
	}

	def void checkAssignmentType(Assignment a, Map<String, Map<String, Object>> types, String prefix) {
		if (a.value?.value instanceof Component) {
			for (ass : (a.value?.value as Component).assignment) {
				checkAssignmentType(ass, types, a.name + ":")
			}
		} else {
			checkTypeRule(types, a, prefix)
		}
	}

	@Check
	def checkOnlyEffectorAsSupertype(Effector effector) {
		var st = effector.superType
		if (st !== null) {
			if (!st.type) {
				val v = effector.eResource.resourceSet.resources
				val effectorTypes = newHashSet
				for (r : v) {
					val res = r.allContents
					res.forEach[
						if (it instanceof Effector && (it as Effector).type) {
							effectorTypes.add(it)
						}
					]
				}
				error(
					"An effector can only extend an effector type",
					RclPackage.Literals.EFFECTOR__SUPER_TYPE,
					ONLY_EXTEND_EFFECTOR_TYPES,
					effectorTypes.join(","),
					"effector type"
				)
			}
		}
	}

	@Check
	def checkEffectorContainsRequiredAttributes(Effector effector) {
		if (!effector.type) {
			checkAttributes(
				effector?.body?.assignment,
				effector?.superType?.body?.assignment,
				ConfigAttributeConstants.ALL_OFREQUIRED_EFFECTOR_FIELDS,
				ConfigAttributeConstants.ONE_OFREQUIRED_EFFECTOR_FIELDS,
				RclPackage.Literals.EFFECTOR__BODY
			)
		}
		for (Assignment a : effector.body?.assignment) {
			checkAssignmentType(a, ConfigAttributeConstants.EFFECTOR_PROPERTY_TYPES, "")

		}
	}

	@Check
	def checkGaugeContainsRequiredAttributes(Gauge gauge) {
		checkAttributes(
			gauge?.body?.assignment,
			gauge?.superType?.body?.assignment,
			ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_FIELDS,
			ConfigAttributeConstants.OPTIONAL_GUAGE_FIELDS,
			RclPackage.Literals.GAUGE__BODY
		)
		checkSubAttributes(
			gauge?.body?.assignment,
			gauge?.superType?.body?.assignment,
			ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_SUBFILEDS,
			ConfigAttributeConstants.ONE_OFREQUIRED_GAUGE_SUBFILEDS,
			RclPackage.Literals.GAUGE__BODY
		)
		for (Assignment a : gauge.body?.assignment) {
			checkAssignmentType(a, ConfigAttributeConstants.GAUGE_PROPERTY_TYPES, "")

		}
		if (gauge.superType !== null) {
			val setupT = gauge.superType.body.assignment.findFirst[it.name == 'setup']?.value?.value
			val setupI = gauge.body.assignment.findFirst[it.name == 'setup']?.value?.value
			if (setupT instanceof Component && setupI instanceof Component) {
				val setupsInType = (setupT as Component).assignment.filter[!ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_SUBFILEDS?.get('setup')?.contains(it.name)].filter[!ConfigAttributeConstants.ONE_OFREQUIRED_GAUGE_SUBFILEDS?.get('setup')?.contains(it.name)]
				val setupsInInstance = (setupI as Component).assignment.filter[!ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_SUBFILEDS?.get('setup')?.contains(it.name)].filter[!ConfigAttributeConstants.ONE_OFREQUIRED_GAUGE_SUBFILEDS?.get('setup')?.contains(it.name)]
				val setup = gauge.body.assignment.findFirst[it.name == 'setup']
				val noSetupDefaults =  setupsInType.filter[it?.value?.value instanceof Reference]
				checkWithGaugeType(setupsInType, setupsInInstance, gauge, noSetupDefaults, setup)
			}
		
			val configT = gauge.superType.body.assignment.findFirst[it.name == 'config']?.value?.value
			val configI = gauge.body.assignment.findFirst[it.name == 'config']?.value?.value
			if (configT instanceof Component && configI instanceof Component) {
				var configInType = (configT as Component).assignment.filter[
					!ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_SUBFILEDS?.get('config')?.contains(it.name)
				]
				configInType = configInType.filter[
					!ConfigAttributeConstants.ONE_OFREQUIRED_GAUGE_SUBFILEDS?.get('config')?.contains(it.name)
				]
				val configInInstance = (configI as Component).assignment.filter[!ConfigAttributeConstants.ALL_OFREQUIRED_GAUGE_SUBFILEDS?.get('config')?.contains(it.name)].filter[!ConfigAttributeConstants.ONE_OFREQUIRED_GAUGE_SUBFILEDS?.get('config')?.contains(it.name)]
				checkWithGaugeType(configInType, configInInstance,gauge, configInType.filter[it?.value?.value instanceof Reference],  gauge.body.assignment.findFirst[it.name == 'config'])
			
			}
		}
	}
	
	protected def void checkWithGaugeType(Iterable<Assignment> setupsInType, Iterable<Assignment> setupsInInstance, Gauge gauge, Iterable<Assignment> noSetupDefaults, Assignment setup) {
		val TypeSetupNames = newLinkedList
		TypeSetupNames.addAll(setupsInType.map[it.name])
		for (p : setupsInInstance) {
			if (!TypeSetupNames.contains(p.name)) {
				warning('''Property «p.name» is not defined in type «gauge.superType.name»''', p,
					RclPackage.Literals.ASSIGNMENT__NAME
				)
			} 
			val pIntype = setupsInType.findFirst[it.name==p.name]?.value?.value
			var typechecks = false
			if (pIntype instanceof Reference) {
				val type = (pIntype as Reference).referable
				typechecks = switch type.qualifiedName {
					case typeof(Integer).name : p?.value?.value instanceof IntegerLiteral
					case typeof(String).name: p?.value?.value instanceof StringLiteral
					case typeof(Boolean).name: p?.value?.value instanceof BooleanLiteral
					case typeof(Double).name: p?.value?.value instanceof IntegerLiteral || p?.value?.value instanceof DoubleLiteral
					default: false
				}
			}
			else if (pIntype instanceof DoubleLiteral) {
				typechecks = p?.value?.value instanceof DoubleLiteral || p?.value?.value instanceof IntegerLiteral
			}
			else {
				typechecks = p?.value?.value?.class == pIntype?.class
			}
			if (!typechecks) {
				
				error('''The type of «p.name» does not match in the gauge type''', p, 
					RclPackage.Literals.ASSIGNMENT__NAME
				)
			}
			TypeSetupNames.remove(p.name)
		}
		
		if (!TypeSetupNames.empty && !noSetupDefaults.empty) {
			val badNames = noSetupDefaults.filter[TypeSetupNames.contains(it.name)].map[it.name]
			error('''The «(badNames.length > 1)?"properties":"property"» «badNames.join(", ")» need(s) to be given a value in this instance''', setup, RclPackage.Literals.ASSIGNMENT__VALUE, MISSING_PROPERTY, badNames.join(","))
		}
	}

//	@Check
//	def checkProbeValue(ProbeReference v) {
//		var p = v.eContainer
//		while (p != null && !(p.eContainer instanceof Probe))
//			p = p.eContainer
//		if (p != null) {
//			error(
//				"A probe cannot refer to another probe",
//				RclPackage.Literals.PROBE_REFERENCE__REFERABLE,
//				"noProbeReferencesInProbe"
//			)
//		}
//	}
	@Check
	def checkUtilityAssignment(Assignment ass) {
		val dp = EcoreUtil2.getContainerOfType(ass, DeclaredProperty)
		if (dp !== null && dp.component === ComponentType.UTILITY) {
			val sb = new StringBuffer()
			var eContainer = ass as EObject
			while (eContainer !== null) {
				eContainer = eContainer.eContainer
				if (eContainer instanceof Assignment) {
					sb.insert(0, ':')
					val par = (eContainer as Assignment)
					if (ConfigAttributeConstants.UTILITY_PROPERTY_TYPES.containsKey(par.name)) {
						sb.insert(0, par.name)
					}
				}
			}
			checkTypeRule(ConfigAttributeConstants.UTILITY_PROPERTY_TYPES, ass, sb.toString)
		}
	}

	@Check
	def checkAttributes(EList<Assignment> list, EList<Assignment> superlist, Set<String> requiredfields,
		Set<String> optionalFields, EReference reference) {
		for (String req : requiredfields) {
			var hasReq = list.exists [
				it.name == req
			];
			if (!hasReq && superlist !== null) {
				hasReq = superlist.exists [
					return it.name == req
				];
			}
			if (!hasReq) {
				warning(
					'''Expecting required field "«req»"''',
					reference,
					MISSING_PROPERTY,
					req
				)
			}
		}
		if (!optionalFields.isEmpty) {
			var hasOpt = false;
			for (String opt : optionalFields) {
				hasOpt = hasOpt || list.exists[return it.name == opt]
				if (superlist != null) {
					hasOpt = hasOpt || superlist.exists[return it.name == opt]
				}
			}
			if (!hasOpt) {
				var fields = optionalFields.map([return "\"" + it + "\""]).join(", ")
				warning(
					'''Expecting one of field «fields»''',
					reference,
					MISSING_PROPERTY,
					optionalFields.map[it].join(",")
				)
			}
		}

	}

	def checkSubAttributes(EList<Assignment> list, EList<Assignment> superlist, Map<String, Set<String>> allOfSubfields,
		Map<String, Set<String>> oneOfSubfields, EReference reference) {
		for (String key : allOfSubfields.keySet) {
			val compoundElement = list.findFirst [
				it.name == key && it?.value !== null && it.value.value instanceof Component
			]
			var hasCompoundReq = compoundElement !== null
			if (!hasCompoundReq && superlist !== null) {
				hasCompoundReq = superlist.exists [
					it.name == key && it?.value !== null && it.value.value instanceof Component
				]
			}
			if (!hasCompoundReq) {
				warning(
					'''Expecting required compound attribute "«key»"''',
					reference,
					MISSING_PROPERTY,
					key,
					Component.name
				)
			} else {
				val att = list != null ? list.stream.filter([it.name == key]).findAny : null
				val superAtt = superlist != null ? superlist.stream.filter([it.name == key]).findAny : null
				val allKeys = new HashSet<String>()
				if (att !== null && att.present) {
					allKeys.addAll((att.get.value.value as Component).assignment.map([it.name]))
				}
				if (superAtt !== null && superAtt.present) {
					allKeys.addAll((superAtt.get.value.value as Component).assignment.map[it.name])
				}
				if (!allKeys.containsAll(allOfSubfields.get(key))) {
					var fields = allOfSubfields.get(key).stream.filter([!allKeys.contains(it)]).collect(
						Collectors.toList)
					var fs = fields.map([return "\"" + it + "\""]).join(", ")
					if (compoundElement != null) {
						warning(
							'''"«key»" is missing the required fields «fs».''', 
							compoundElement,
							RclPackage.Literals.ASSIGNMENT__VALUE,
							MISSING_PROPERTY,
							fields.map[it].join(",")
						)
					} else {
						warning(
							'''"«key»" is missing the required fields «fs».''',
							reference,
							MISSING_PROPERTY,
							fields.map[it].join(","),
							key
						)
					}
				}
				val oneof = oneOfSubfields.get(key)
				if (oneof !== null) {
					var hasOneOf = false
					for (sk : oneof) {
						hasOneOf = hasOneOf || allKeys.contains(sk)
					}
					if (!hasOneOf) {
						warning(
							'''"«key»" should have one of «oneof.map["'" + key + "'"].join(", ")».''',
							reference,
							MISSING_PROPERTY,
							oneof.map[it].join(","),
							key
						)
					}
				}
			}
		}

	}

	@Inject
	@Named("jvmtypes") private IJvmTypeProvider.Factory jvmTypeProviderFactory;

	@Inject
	private RawSuperTypes superTypeCollector;

	@Check
	def checkGaugeTypeModelFactory(GaugeTypeBody gaugeType) {
		var model = gaugeType.mcf
		if (model instanceof Reference) {
			if (model.referable instanceof JvmType) {
				var java = model.referable as JvmType
				var jvmTypeProvider = jvmTypeProviderFactory.createTypeProvider(gaugeType.eResource.resourceSet);

				var I2I = jvmTypeProvider.findTypeByName(MODEL_COMMAND_FACTORY_SUPERCLASS);
				var sts = superTypeCollector.collect(java);
				if (!sts.contains(I2I)) {
					error(
						'''«java.identifier» does not extend  «MODEL_COMMAND_FACTORY_SUPERCLASS»''',
						RclPackage.Literals.GAUGE_TYPE_BODY__MCF,
						RclValidator.MUST_SUBCLASS,
						MODEL_COMMAND_FACTORY_SUPERCLASS,
						sts.map[it.qualifiedName].join(","),
						"factory type"
					)
				}
			}

		}
	}

	@Check
	def checkGaugeBody(GaugeTypeBody gb) {
		var Boolean hasRegExpCommand = null;
		for (cmd : gb.commands) {
			if (hasRegExpCommand === null) {
				hasRegExpCommand = cmd.regexp !== null
			} else {
				if (hasRegExpCommand && (cmd.regexp === null)) {
					error(
						'''Mixing commands with and without regular expression is not supported.''',
						cmd,
						RclPackage.Literals.COMMAND_REFERENCE__NAME,
						"mixedcommands"
					)
				}
			}
		}
		if (hasRegExpCommand != null && hasRegExpCommand) {
			var noGeneratedClass = true
			var additional = ""
			val setupProp = gb.assignment.findFirst[it.name == "setup"]
			val setup = setupProp?.value.value
			if (setup instanceof Component) {
				val gcProp = (setup as Component).assignment.findFirst[it.name == "generatedClass"]
				if (gcProp == null) {
					val javaClass = (setup as Component).assignment.findFirst[it.name == "javaClass"]
					if (javaClass !== null) {
						additional = " Perhaps change javaClass to generatedClass?"
//						error("Gauges with regular expressions should have generatedClass",
//							javaClass,
//							RclPackage.Literals.ASSIGNMENT,
//							"noGeneratedClass",
//							"generatedClass"
//							
//						)
					}
//					else {
						error(
							'''Gauge has regular expression, so "generatedClass" should be specified.''',
							setupProp,
							RclPackage.Literals.ASSIGNMENT__VALUE,
							MISSING_PROPERTY,
							"generatedClass"
						)
//					}
				} else {
					val gc = gcProp?.value?.value
					if (gc instanceof StringLiteral) {
						noGeneratedClass = false;
						try {
							val className = XtendUtils.unpackString(gc as StringLiteral, true, true)
							val clazz = Class.forName(className)
							warning(
								'''"«className»" already exists''',
								gcProp,
								RclPackage.Literals.ASSIGNMENT__VALUE,
								"badclass"
							)
						} catch (Exception e) {
						}
					} else {
						error(
							'''Value should be a string''',
							gcProp,
							RclPackage.Literals.ASSIGNMENT__VALUE,
							"badclass"
						)
					}
				}
			} else {
				error(
					'''Gauge has regular expression, so "generatedClass" should be specified in setup''',
					setup,
					RclPackage.Literals.ASSIGNMENT__VALUE,
					MISSING_PROPERTY,
					"generatedClass"
				)
			}
		}
		for (Assignment a : gb.assignment) {
			checkAssignmentType(a, ConfigAttributeConstants.GAUGE_PROPERTY_TYPES, "")

		}
		
	}

	@Check
	def checkCommandCall(CommandCall cc) {
		val gb = EcoreUtil2.getContainerOfType(cc, GaugeBody)
		if (gb !== null) {
			val g = EcoreUtil2.getContainerOfType(gb, Gauge)
			var Object modelFactory = null
			if (gb.ref?.referable instanceof DeclaredProperty &&
				(gb.ref?.referable as DeclaredProperty)?.component == ComponentType.MODEL &&
				(gb.ref?.referable as DeclaredProperty)?.value.value instanceof Component) {
				modelFactory = ((gb.ref.referable as DeclaredProperty).value.value as Component).assignment.findFirst [
					it.name == "factory"
				]
//				if (factory )
//				if (factory?.value?.value instanceof Reference && (factory.value.value as Reference).referable instanceof JvmDeclaredType) {
//					modelFactory = (factory.value.value as Reference).referable as JvmDeclaredType
//				}
			} else {
				if (g.superType !== null) {
					modelFactory = g.superType.body.mcf
//					if (g.superType.body.mcf.java.refera instanceof JvmDeclaredType)
//						modelFactory = g.superType.body.mcf as JvmDeclaredType
				}
			}
			if (modelFactory === null) {
				warning(
					'''Cannot check "«cc.command»" because no referenced model''',
					RclPackage.Literals.COMMAND_CALL__COMMAND,
					"cannotCheckCommand"
				)
			}
			if (g.superType !== null) {
				if (g.superType.body.commands.findFirst [
					it.name == cc.name
				] === null) {
					val commandNamesInGauge = g.body.commands.map[it.name]
					val possibleRenamesInGauge = g.superType.body.commands.map[it.name].filter[!commandNamesInGauge.contains(it)].join(",")
					error(
						'''The command "«cc.name»" does not exists in «g.superType.name»''',
						RclPackage.Literals.COMMAND_CALL__NAME,
						RclValidator.COMMAND_NOT_IN_GAUGE_TYPE,
						possibleRenamesInGauge
					)
				}
			}
			checkCommandCallElements(cc, modelFactory)
			return

		}
		val ef = EcoreUtil2.getContainerOfType(cc, Effector)
		if (ef !== null) {
			var Object modelFactory = null
			if (ef.body?.ref?.referable instanceof DeclaredProperty &&
				(ef.body?.ref?.referable as DeclaredProperty)?.component == ComponentType.MODEL &&
				(ef.body?.ref?.referable as DeclaredProperty)?.value.value instanceof Component) {
				val factory = ((ef.body?.ref.referable as DeclaredProperty).value.value as Component).assignment.
					findFirst[it.name == "factory"]
//				if (factory?.value?.value instanceof Reference) {
//					modelFactory = (factory.value.value as Reference).referable as JvmDeclaredType
//				}
//				else if (factory instanceof Assignment && factory?.value?.value instanceof PropertyReference) {
//					modelFactory = (factory?.value?.value as PropertyReference).referable
//					if (modelFactory instanceof DeclaredProperty && (factory as
//				}
				modelFactory = factory
			}

			if (modelFactory === null) {
				warning(
					'''Cannot check "«cc.command»" because no referenced model''',
					RclPackage.Literals.COMMAND_CALL__COMMAND,
					"cannotCheckCommand"
				)
			}
			checkCommandCallElements(cc, modelFactory)
			return
		}
	}

	@Check
	def checkGaugeTypeCommandReferenceRegexp(CommandReference cr) {
		if (cr.regexp !== null) {
			val regexp = XtendUtils.unpackString(cr.regexp, true, true)
			val Set<String> namedGroups = newHashSet

			try {
				Pattern.compile(regexp)
				XtendUtils.fillNamedGroups(regexp, namedGroups)
				if (namedGroups.empty) {
					warning(
						'''""«regexp»" should contain at least one captured group''',
						RclPackage.Literals.COMMAND_REFERENCE__REGEXP,
						"badregexp"
					)
				}
			} catch (PatternSyntaxException e) {
				error(
					'''«e.message»''',
					RclPackage.Literals.COMMAND_REFERENCE__REGEXP,
					"badregexp"
				)
			}
		}
	}

	@Check
	def checkGaugeCommands(Gauge g) {
		if (g.superType !== null) {
			val typeCommands = g.superType.body.commands
			for (cmd : g.body.commands) {
				val tcmd = typeCommands.findFirst[it.name == cmd.name]
				if (tcmd?.regexp !== null) {
					val Set<String> namedGroups = newHashSet
					val regexp = XtendUtils.unpackString(tcmd.regexp, true)
					XtendUtils.fillNamedGroups(regexp, namedGroups)
				}
			}
		}
	}
	
	def hasTarget(CommandCall cc) {
		cc.ref !== null || cc.target !== null
	}

	def checkCommandCallElements(CommandCall cc, Object modelFactory) {
		var Object cmf = null
		if (modelFactory instanceof Assignment) {
			cmf = (modelFactory as Assignment).value.value
		} else if (modelFactory instanceof JavaClassOrFactory) {
			val jcof = (modelFactory as JavaClassOrFactory)
			if(jcof.java !== null) cmf = jcof.java else cmf = jcof.factory
		}
		val command = cc.command
		val Set<String> namedGroups = newHashSet

		val re = EcoreUtil2.getContainerOfType(cc, Gauge)?.superType?.body?.commands?.findFirst[it.name == cc.name]?.
			regexp
		if (re !== null) {
			val regexp = XtendUtils.unpackString(re, true, true)

			try {
				XtendUtils.fillNamedGroups(regexp, namedGroups)
			} catch (PatternSyntaxException e) {
				// Handled in checkGaugeType
			}
		}

		switch cmf {
			Reference case cmf.referable instanceof JvmDeclaredType:
				checkCommandCallElements(cc, command, cmf.referable as JvmDeclaredType)
			PropertyReference case cmf.referable instanceof Factory: {

				val factory = cmf.referable as Factory
				val mf = factory.defn
				var commandMethod = mf.commands.filter[it.name.equalsIgnoreCase(command)]

				if (commandMethod.empty) {
					val validCommands = new LinkedList<String>();
					val gauge = EcoreUtil2.getContainerOfType(cc, Gauge)
					if (gauge !== null) {
						val superTypeCmd =gauge?.superType?.body?.commands?.findFirst[it.name.equalsIgnoreCase(cc.name)]
						if (superTypeCmd !== null) {
							validCommands.add(superTypeCmd.command)
						}
						else {
							validCommands.addAll(mf.commands.filter[it.formal.length == cc.actual.length].map[it.name])
						}
					}
					error(
						'''"«command»" is not a valid command in «(cmf as PropertyReference).referable.name» ''',
						RclPackage.Literals.COMMAND_CALL__COMMAND,
						NOT_VALID_GAUGE_COMMAND,
						validCommands.join(",")
					)
				} else {
					val factoryCommand = commandMethod.get(0)
					if (factoryCommand.formal.size != cc.actual.size + (cc.hasTarget ? 1 : 0)) {
						if (cc.actual === null && factoryCommand.formal.size > 0) {
						} else {
							error(
								'''"«command»" wrong number of parameters defined. Expecting «factoryCommand.formal.size-(cc.hasTarget?1:0)» got «cc.actual.size»''',
								RclPackage.Literals.COMMAND_CALL__ACTUAL,
								"wrongparamnumbers"
							)

						}
					} else {
						for (actual : cc.actual) {
							if (actual.ref && re !== null) {
								var name = actual.ng
								var lit = RclPackage.Literals.ACTUAL__NG
								if (name === null) {
									name = Integer.toString(actual.ag)
									lit = RclPackage.Literals.ACTUAL__AG
								}
								if (!namedGroups.contains(name)) {
									warning(
										'''«name» should be a valid group from «XtendUtils.unpackString(re, true)»''',
										actual,
										lit,
										"badregexpreference"
									)
								}
							}
						}
					}
//				else {
//					var i = 0
//					for (param : factoryCommand.formal) {
//						if (param.name != "target") {
//							val paramTypeName = getTypeName(param)
//							if (paramTypeName != cc.actual.get(i).) {
//								error(
//										'''Parameter «i» expecting «paramTypeName», received «cr.formal.get(i).simpleName».''',
//										RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
//										"wrongType"
//									)
//							}
//							i = i + 1
//						}
//						else {
//							val paramTypeName = getTypeName(param)
//							if (paramTypeName != cr.target) {
//								error(
//										'''Target type expecting «paramTypeName», received «cr.target».''',
//										RclPackage.Literals.COMMAND_REFERENCE__TARGET,
//										"wrongType"
//									)
//							}
//						}
//					}
//				}
				}
			}
		}
	}

	protected def  checkCommandCallElements(CommandCall cc, String command, JvmDeclaredType mf) {
		var commandMethod = mf.members.filter[it instanceof JvmOperation].filter [
			it.simpleName.equalsIgnoreCase(command) || it.simpleName.equalsIgnoreCase(command + "cmd")
		]

		if (commandMethod.empty) {
			error(
				'''"«command»" is not a valid command in «mf.identifier» ''',
				RclPackage.Literals.COMMAND_CALL__COMMAND,
				"nocommand"
			)
		} else {
			var method = commandMethod.get(0) as JvmOperation
			if (method.parameters.size != cc.actual.size + (cc.hasTarget ? 1 : 0)) {
				if (cc.actual == null && method.parameters.size > 0) {
				} else {
					error(
						'''"«command»" wrong number of parameters defined. Expecting «method.parameters.size-(cc.hasTarget?1:0)» got «cc.actual.size»''',
						RclPackage.Literals.COMMAND_CALL__ACTUAL,
						"wrongparamnumbers"
					)

				}
			}
		}
	}

	@Check
	def checkCommandSignature(CommandReference cr) {
		if (cr.eContainer.eClass == RclPackage.Literals.GAUGE_TYPE_BODY) {
			var gaugeType = cr.eContainer as GaugeTypeBody
			if (gaugeType !== null) {
				if (gaugeType.mcf !== null) {
					val mcf = gaugeType.mcf
					if (mcf instanceof Reference &&
						!((mcf as Reference).referable instanceof JvmDeclaredType ||
							(mcf as Reference).referable instanceof Factory)) {
						warning(
							'''"«cr.command» cannot be checked because there is no model defined"''',
							RclPackage.Literals.COMMAND_REFERENCE__COMMAND,
							"cannotCheckCommand"
						)
						return
					}
				}
			}
			val command = cr.command

			val java = gaugeType.mcf instanceof Reference && (gaugeType.mcf as Reference).referable instanceof JvmDeclaredType ? (gaugeType.mcf as Reference).
					referable as JvmDeclaredType : null
			val factory = gaugeType.mcf instanceof PropertyReference && (gaugeType.mcf as PropertyReference).referable instanceof Factory ? (gaugeType.mcf as PropertyReference).referable as Factory : null

			if (java !== null) {
				var type = java

				var commandMethod = type.members.filter[it instanceof JvmOperation].filter [
					it.simpleName.equalsIgnoreCase(command) || it.simpleName.equalsIgnoreCase(command + "cmd")
				]

				if (commandMethod.empty) {
					error(
						'''"«command»" is not a valid command in «type.identifier» ''',
						RclPackage.Literals.COMMAND_REFERENCE__COMMAND,
						"nocommand"
					)
				} else {
					var method = commandMethod.get(0) as JvmOperation
					if (method.parameters.size != cr.formal.size + (cr.target != null ? 1 : 0)) {
						if (cr.formal == null && method.parameters.size > 0) {
						} else {
							error(
								'''"«cr.command»" wrong number of parameters defined. Expecting «method.parameters.size-(cr.target!=null?1:0)» got «cr.formal.size»''',
								RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
								"wrongparamnumbers"
							)
							return
						}
					}
					var first = true
					val prim = new Primitives()
					var i = 0
					for (param : method.parameters) {
						if (first && cr.target != null) {
							if (prim.isPrimitive(param.parameterType)) {
								warning(
									'''«type.simpleName».«method.simpleName» may need a target''',
									RclPackage.Literals.COMMAND_REFERENCE__COMMAND,
									"mayNeedTarget"
								)
							}
						} else {
							if (param.parameterType.simpleName != cr.formal.get(i).simpleName) {
								error(
									'''Parameter «i» expecing «param.parameterType.simpleName», received «cr.formal.get(i).simpleName».''',
									RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
									"wrongType"
								)
							}
							i = i + 1
						}
						first = false
					}
				}

			} else if (factory != null) {

				val factoryCommands = factory.defn.commands.filter[it.name.equalsIgnoreCase(command)]
				if (factoryCommands.empty) {
					error(
						'''"«command»" is not a valid command in «factory.name» ''',
						RclPackage.Literals.COMMAND_REFERENCE__COMMAND,
						"nocommand"
					)
				} else {
					val factoryCommand = factoryCommands.get(0)
					if (factoryCommand.formal.size != cr.formal.size + (cr.target != null ? 1 : 0)) {
						if (cr.formal == null && factoryCommand.formal.size > 0) {
							return
						} else {
							error(
								'''"«cr.command»" wrong number of parameters defined. Expecting «factoryCommand.formal.size-(cr.target!=null?1:0)» got «cr.formal.size»''',
								RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
								"wrongparamnumbers"
							)
							return
						}
					}
					// Check the targets
					if (factoryCommand.formal.findFirst[it.name == "target"] !== null && cr.target === null) {
						error(
							'''"«cr.command»" does not specify a needed target''',
							RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
							"wrongparamnumbers"
						)
						return
					}
					if (cr.target !== null && factoryCommand.formal.findFirst[it.name == "target"] === null) {
						error(
							'''«cr.command» specifies a target not in the factory: «cr.target»''',
							RclPackage.Literals.COMMAND_REFERENCE__TARGET,
							"unknowntarget"
						)
					}
					var i = 0
					for (param : factoryCommand.formal) {
						if (param.name != "target") {
							val paramTypeName = ModelUtil.getTypeName(param)
							if (paramTypeName != cr.formal.get(i).simpleName) {
								error(
									'''Parameter «i» expecting «paramTypeName», received «cr.formal.get(i).simpleName».''',
									RclPackage.Literals.COMMAND_REFERENCE__FORMAL,
									"wrongType"
								)
							}
							i = i + 1
						} else {
							val paramTypeName = ModelUtil.getTypeName(param)
							if (paramTypeName != cr.target) {
								error(
									'''Target type expecting «paramTypeName», received «cr.target».''',
									RclPackage.Literals.COMMAND_REFERENCE__TARGET,
									"wrongType"
								)
							}
						}
					}
				}
			}
//			var tries=[cr.command, cr.command.toLowerCase, cr.commmand]
//			while (method == null)
		}
	}

	
 
	@Check
	def checkClassAssignments(DeclaredProperty assignment) {
		if (assignment?.value?.value instanceof Reference) {
			val subType = (assignment.value.value as Reference).referable
			if (assignment.name.matches(".*class_[0-9]+$")) {
				val checkName = assignment.name.substring(0, assignment.name.lastIndexOf('_')) + "*"
				val superClass = ConfigAttributeConstants.PROPERTY_VALUE_CLASSES.get(checkName)
				if (superClass !== null) {
					val jvmTypeProvider = jvmTypeProviderFactory.createTypeProvider(assignment.eResource.resourceSet)
					val superType = jvmTypeProvider.findTypeByName(superClass)
					var sts = superTypeCollector.collect(subType)
					if (!sts.contains(superType)) {
						error(
							'''«subType.simpleName» is not a subclass of «superClass»''',
							RclPackage.Literals.DECLARED_PROPERTY__VALUE,
							RclValidator.MUST_SUBCLASS,
							superClass
						)
					}
				}
			}
		}
		
			checkTypeRule(ConfigAttributeConstants.PROPERTY_VALUE_TYPES, "", assignment.name, assignment.value, assignment, RclPackage.Literals.DECLARED_PROPERTY__VALUE)
			
	}

	@Check
	def checkComponentPropertiesAreComponent(DeclaredProperty dp) {
		if (dp.component != ComponentType.PROPERTY) {
			if (!(dp.value.value instanceof Component)) {
				error(
					'''Values for «dp.component» must be compound values''',
					RclPackage.Literals.DECLARED_PROPERTY__VALUE,
					"incorrectValue"
				)
			}
		}
	}

	@Check
	def checkComponentPropertyFields(DeclaredProperty dp) {
		if (dp.component != ComponentType.PROPERTY) {
			switch dp.component {
				case ANALYSIS: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_ANALYSIS_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)

				}
				case EFFECTORMANAGER: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_EFFECTOR_MANAGER_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)

				}
				case EXECUTOR: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_EXECUTOR_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)
				}
				case GUI: {
				}
				case MANAGER: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_MANANGER_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)

				}
				case MODEL: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_MODEL_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)
				}
				case PROPERTY: {
				}
				case UTILITY: {
					checkAttributes((dp.value.value as Component).assignment, null,
						ConfigAttributeConstants.ALL_OFREQUIRED_UTILITY_FIELDS, #{},
						RclPackage.Literals.DECLARED_PROPERTY__VALUE)
				}
			}
		}
	}

	@Check
	def checkComponentPropertyFieldTypes(Assignment dp) {
		val parent = EcoreUtil2.getContainerOfType(dp, DeclaredProperty)
		if (parent?.component !== null && parent?.component == ComponentType.GUI) {
			var rent = EcoreUtil2.getContainerOfType(dp.eContainer, Assignment);
			var name = ""
			while (rent !== null) {
				name = rent.name + ":" + name
				rent = EcoreUtil2.getContainerOfType(rent.eContainer, Assignment);
			}
			checkTypeRule(ConfigAttributeConstants.GUI_PROPERTY_TUPES, dp, name)
		} else if (parent?.component !== null && parent?.component != ComponentType.PROPERTY) {
			val rule = ConfigAttributeConstants.COMPONENT_PROPERTY_TYPES.get(parent.component)
			checkTypeRule(rule, dp)
		}
	}

	def void checkTypeRule(Map<String, Map<String, Object>> rule, Assignment dp) {
		checkTypeRule(rule, "",  dp.name, dp.value, dp, RclPackage.Literals.ASSIGNMENT__VALUE)
	}

	protected def void checkTypeRule(Map<String, Map<String, Object>> rule, Assignment dp, String prefix) {
		checkTypeRule(rule, prefix, dp.name, dp.value, dp, RclPackage.Literals.ASSIGNMENT__VALUE)
	}
	
	protected def void checkTypeRule(Map<String, Map<String, Object>> rule, String prefix, String name, Value value, EObject target, EStructuralFeature feature) {
		if (rule !== null) {
			val lookupName = prefix == "" ? name : (prefix + name)
			val fieldRule = rule.get(lookupName) as Map<String, Object>
			if (fieldRule !== null) {
				val (Value)=>boolean func = fieldRule.get('func') as (Value)=>boolean
				if (func !== null) {
					if (!func.apply(value)) {
						error(
							'''«name» «fieldRule.get('msg')»''',
							target,
							feature,
							"invalidType"
						)
					}
				} else {
					var extends = fieldRule.get('extends') as List<Class>
					var ok = false
					for (class : extends) {
						ok = ok || checkClass(value, class)
					}
					if (!ok) {
						error(
							'''«name» «fieldRule.get('msg')»''',
							target,
							feature,
							MUST_SUBCLASS,
							extends.map[it.name].join(",")
						)
					}
					if (extends.contains(Array) && value.value instanceof Array) {
						val furtherCheck = fieldRule.get(
							'checkEach') as Function1<Array, LinkedList<Triple<String, EObject, EStructuralFeature>>>
						for (e : furtherCheck.apply(value.value as Array)) {
							error(e.first, e.second, e.third)
						}
					}
				}

			}

		}
	}

	protected def boolean checkClass(Value dp, Class clazz) {
		if(clazz == StringLiteral) return dp.value instanceof StringLiteral
		if(clazz == BooleanLiteral) return dp.value instanceof BooleanLiteral
		if(clazz == IntegerLiteral) return dp.value instanceof IntegerLiteral
		if(clazz == DoubleLiteral) return dp.value instanceof DoubleLiteral
		if(clazz == Component) return dp.value instanceof Component
		if(clazz == IPLiteral) return dp.value instanceof IPLiteral
		if(clazz == PropertyReference) return dp.value instanceof PropertyReference
//		if(clazz == ProbeReference) return dp.value.value instanceof ProbeReference
		if(clazz == Array) return dp.value instanceof Array
		ConfigAttributeConstants.subclasses(dp, clazz.name)
	}

	public static val CHECK_UTILITY_MONOTONIC = [ Array a |
		{
			val errors = new LinkedList<Triple<String, EObject, EStructuralFeature>>()
			var first = true
			var double lastVal = 0.0
			var goingUp = false
			var goingDown = false
			for (v : a.values) {
				if (!(v.value instanceof Array)) {
					errors.add(
						Tuples.create('''Array value needs to be an array of two numbers''', v,
							RclPackage.Literals.VALUE__VALUE))
				} else {
					val pair = v.value as Array
					if (pair.values.size != 2) {
						errors.add(
							Tuples.create('''Array value needs to be an array of two numbers''', v,
								RclPackage.Literals.VALUE__VALUE))
					} else {
						val thisVal = getNumber(pair.values.get(1))
						if (!first) {
							if (lastVal < thisVal) {
								goingUp = true
							} else if (lastVal > thisVal) {
								goingDown = true
							}
						} else {
							first = false
						}
						lastVal = thisVal
					}

				}
			}
			if (goingUp && goingDown) {
				errors.add(Tuples.create('''Utilities need to be monotonic''', a, RclPackage.Literals.ARRAY__VALUES))
			}
			errors

		}
	]

	public static val CHECK_EACH_SCENARIO = [ Array a |
		{
			val errors = new LinkedList<Triple<String, EObject, EStructuralFeature>>()
			val dp = Utils.getContainerOfType(a, Component, [ EObject v |
				v instanceof Component && (v as Component).assignment.exists[it.name == "utilities"]
			])
			var definedUtilities = (dp.assignment.findFirst[it.name == "utilities"]?.value.value as Component).
				assignment.map[it.name]
			for (v : a.values) {
				if (!(v.value instanceof Component)) {
					errors.add(
						Tuples.create('''Scenario should only contain composites''', a,
							RclPackage.Literals.ARRAY__VALUES))
				} else {
					var sum = 0.0
					val scenario = v.value as Component
					for (ass : scenario.assignment) {
						if (ass.name != 'name') {
							sum += getNumber(ass.value)
							if (!definedUtilities.contains(ass.name)) {
								errors.add(
									Tuples.create('''«ass.name» must refer to a utility defined in utilities''', ass,
										RclPackage.Literals.ASSIGNMENT__NAME))
							}
						}
					}
					if (sum != 1.0) {
						errors.add(
							Tuples.create('''The utilities in a scenario must sum to 1''', scenario,
								RclPackage.Literals.COMPONENT__ASSIGNMENT))
					}
				}
			}
			errors
		}
	]

	def static getNumber(Value value) {
		val v = value.value
		switch v {
			IntegerLiteral: Double.valueOf(v.value)
			DoubleLiteral: Double.valueOf(v.value)
			default: 0.0
		}
	}

	@Check
	def checkImpact(ImpactVector iv) {
		if (!(iv.utilityModel.referable instanceof DeclaredProperty) ||
			(iv.utilityModel.referable as DeclaredProperty)?.component !== ComponentType.UTILITY) {
			error(
				'''Impact vector referring to non-utility model «iv.utilityModel.referable?.name»''',
				iv,
				RclPackage.Literals.IMPACT_VECTOR__UTILITY_MODEL
			)
			return
		}
		var definedUtilities = (((iv.utilityModel.referable as DeclaredProperty).value.value as Component).
			assignment.findFirst [
				it.name == "utilities"
			]?.value.value as Component).assignment.map[it.name]
		for (ass : iv.component.assignment) {
			if (!definedUtilities.contains(ass.name)) {
				error('''Undefined utility «ass.name»''', ass, RclPackage.Literals.ASSIGNMENT__NAME)
			}
		}
	}

	static val LOAD_MODEL_CMD_SUPERCLASS = typeof(AbstractLoadModelCmd).name
	static val SAVE_MODEL_CMD_SUPERCLASS = typeof(AbstractSaveModelCmd).name
	static val MODEL_COMMAND_FACTORY_SUPERCLASS = typeof(ModelCommandFactory).name
	static val RAINBOW_OPERATION_SUPERCLASS = typeof(AbstractRainbowModelOperation).name
	static val MODEL_SUPERCLASS = typeof(IModelInstance).name
	
	
	@Check
	def checkFactoryDefinition(FactoryDefinition factory) {
		if (!ConfigAttributeConstants.subclasses(factory.loadCmd, RclValidator.LOAD_MODEL_CMD_SUPERCLASS,
			factory.eResource)) {
			error(
				'''«factory.loadCmd.qualifiedName» must subclass «RclValidator.LOAD_MODEL_CMD_SUPERCLASS»''',
				factory,
				RclPackage.Literals.FACTORY_DEFINITION__LOAD_CMD,
				MUST_SUBCLASS,
				RclValidator.LOAD_MODEL_CMD_SUPERCLASS
			)
		}
		if (factory.saveCmd !== null &&
			!ConfigAttributeConstants.subclasses(factory.saveCmd, SAVE_MODEL_CMD_SUPERCLASS, factory.eResource)) {
			error(
				'''«factory.saveCmd.qualifiedName» must subclass «SAVE_MODEL_CMD_SUPERCLASS»''',
				factory,
				RclPackage.Literals.FACTORY_DEFINITION__SAVE_CMD,
				MUST_SUBCLASS,
				SAVE_MODEL_CMD_SUPERCLASS
			)
		}
		if (factory.extends !== null &&
			!ConfigAttributeConstants.subclasses(factory.extends, MODEL_COMMAND_FACTORY_SUPERCLASS,
				factory.eResource)) {
			error(
				'''«factory.saveCmd.qualifiedName» must subclass «MODEL_COMMAND_FACTORY_SUPERCLASS»''',
				factory,
				RclPackage.Literals.FACTORY_DEFINITION__EXTENDS,
				MUST_SUBCLASS,
				MODEL_COMMAND_FACTORY_SUPERCLASS
			)
		}
		if (!ConfigAttributeConstants.subclasses(factory.modelClass, MODEL_SUPERCLASS, factory.eResource)) {
			error(
				'''«factory.modelClass.qualifiedName» must subclass «MODEL_SUPERCLASS»''',
				factory,
				RclPackage.Literals.FACTORY_DEFINITION__MODEL_CLASS,
				MUST_SUBCLASS,
				MODEL_SUPERCLASS
			)
		}
	}

	@Check
	def checkCommandDefinition(CommandDefinition cmd) {
		if (!ConfigAttributeConstants.subclasses(cmd.cmd, RAINBOW_OPERATION_SUPERCLASS, cmd.eResource)) {
			error(
				'''«cmd.cmd.qualifiedName» must extend «RAINBOW_OPERATION_SUPERCLASS»''',
				cmd,
				RclPackage.Literals.COMMAND_DEFINITION__CMD,
				MUST_SUBCLASS,
				RAINBOW_OPERATION_SUPERCLASS
			)
		}

		val factory = EcoreUtil2.getContainerOfType(cmd, FactoryDefinition)
		if (!(cmd.cmd instanceof JvmDeclaredType)) {
			return
		}
		val cmdClass = cmd.cmd as JvmDeclaredType
		var compatibleConstructors = cmdClass.declaredConstructors.filter([
			if (it.parameters.size == cmd.formal.size + 2) {
				val firstString = it.parameters.get(0).parameterType.qualifiedName == "java.lang.String"
				val secondModel = it.parameters.get(1).parameterType.qualifiedName == factory.modelClass.qualifiedName
				return firstString && secondModel
			}
			false
		])
		if (compatibleConstructors.nullOrEmpty) {
			var myParams = cmd.formal.map [
				XtendUtils.formalTypeName(it, true)
			].join(", ")
			error(
				'''«cmdClass.simpleName» must have constructor with parameters String, «factory.modelClass.simpleName», «myParams»''',
				cmd,
				RclPackage.Literals.COMMAND_DEFINITION__CMD,
				"ConstructurIncompatible"
			)
		} else {
			val cstr = compatibleConstructors.get(0)
			for (var i = 0; i < cmd.formal.size; i++) {
				if (cstr.parameters.get(i + 2).parameterType.simpleName != "String") {
					val cstrType = cstr.parameters.get(i + 2).parameterType
					val formalType = cmd.formal.get(i)
					if (cstrType.qualifiedName != XtendUtils.formalTypeName(formalType, false)) {
						error(
							'''Found «XtendUtils.formalTypeName(formalType,false)», expecting «cstr.simpleName»''',
							formalType,
							RclPackage.Literals.FORMAL_PARAM__TYPE,
							"incorrectType"
						)
					}
				}
			}
		}
		if (cmd.formal.drop(1).exists[it.name == "target"]) {
			warning(
				'''Only the first argument of a command can be 'target''',
				cmd,
				RclPackage.Literals.COMMAND_DEFINITION__FORMAL,
				"badTarget"
			)
		} else if (cmd.formal.get(0).name != "target") {
			warning(
				'''The first argument of a command should be 'target''',
				cmd,
				RclPackage.Literals.COMMAND_DEFINITION__FORMAL,
				"badTarget"
			)
		}

	}

	@Check
	def checkImport(Import import_) {
		var uri = import_.eResource.URI
		uri = uri.trimSegments(1)
//		uri = uri.appendSegment("/")
		uri = uri.appendSegments(import_.importURI.split("/"))
		if (!import_.eResource.resourceSet.URIConverter.exists(uri, null)) {
			error(
				'''File '«import_.importURI»' not found''',
				import_,
				RclPackage.Literals.IMPORT__IMPORT_URI,
				"badFile"
			)
		}
	}

}
