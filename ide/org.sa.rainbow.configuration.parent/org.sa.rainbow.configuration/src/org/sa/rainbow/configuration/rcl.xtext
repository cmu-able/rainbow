grammar org.sa.rainbow.configuration.Rcl hidden (WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "platform:/resource/org.sa.rainbow.configuration/model/ConfigModel.ecore"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
import "http://www.sa.org/rainbow/stitch/Stitch" as stitch
import "http://www.acme.org/Acme" as acme

generate rcl "http://www.sa.org/rainbow/configuration/RCL"

RainbowConfiguration:
	('target' targetName=FQN 
	imports+=Import*
	(delcaredProperties+=DeclaredProperty)*
	(
		
		(probeTypes+=ProbeType)*
		(probes+=Probe)*
	) 
	(
		(gaugeTypes+=GaugeType)*
		(gauges+=Gauge)*
		
	)
	(
		(effectorTypes+=EffectorType)*
		(effectors+=Effector)*
	)
	(
		(impacts+=ImpactVector)*
	)
	
	
//	exports+=Export*
	export=Export?
	) |
	(
		imports+=Import*
		factories+=Factory*
	)
;

Factory:
	ModelFactory name=ID 'yields' clazz=FQN defn=FactoryDefinition
;

ModelFactory:
	'model' 'factory'
;

FactoryDefinition:
	{FactoryDefinition} 
	'{'
		('extends' extends=[types::JvmType|FQN])?
		'for' modelClass=[types::JvmType|FQN] ';'?
		CommandLoad loadCmd=[types::JvmType|FQN] ';'?
		(CommandSave saveCmd=[types::JvmType|FQN] ';'?)?
		commands+=CommandDefinition*
	
	'}'
;

CommandLoad:
	'command' 'load' 'is'
;

CommandSave:
	'command' 'save' 'is' 
;

CommandDefinition:
	'command' name=ID '(' (formal+=FormalParam (',' formal+=FormalParam)*)?')' 'is' cmd=[types::JvmType|FQN] ';'?
;

FormalParam:
	type=Type name=(ID | 'target')
;


Type:
	 /*{Type} 'int' |  {Type} 'boolean' | {Type} 'double' | {Type} 'String' | */base=BaseType | java=JavaReference | 'acme''::'acme=AcmeReference
;

AcmeReference:
	referable=[acme::AnyTypeRef|FQN]
;

enum BaseType:
	COMPONENT="component" | COMPONENT="Component" |
	CONNECTOR="connector" | CONNECTOR="Connector" |
	PORT="port" | PORT="Port" |
	ROLE="role" | ROLE="Role"
;

JavaReference:
	referable=[types::JvmType|FQN]
;

ImpactVector:
	'impact' utilityModel=PropertyReference tactic=[stitch::tactic] '=' component=Component
;

ModelType:
	ModelTypeKW name=ID ('->' superType=[ModelType])? '=' '{' properties=Component '}'
	('commands' '=' '{' (commands+=CommandSignature)+ '}') 'generate' filename=StringLiteral
;

ModelTypeKW:
	'model' 'type'
;

CommandSignature:
	'command'
;

Export:
	'export' references=References 'to' filename=(RICH_TEXT_DQ)
;

References:
	{References} all?='*' |
	(refs+=[Ref|FQN]) (',' refs+=[Ref|FQN])*
;

Ref:
	DeclaredProperty | Probe | Gauge | Effector
;

enum ComponentType:
	PROPERTY |
	ANALYSIS='analysis' |
	EXECUTOR='executor' |
	EFFECTORMANAGER= 'effector-manager' |
	GUI='gui' |
	MANAGER='adaptation-manager' |
	MODEL='model' |
	UTILITY='utility'
	
;

DeclaredProperty:
	'def' component=(ComponentType)? (type=[types::JvmType|FQN])? name=FQN('=' value=Value)? 
;

ProbeType returns Probe:
	'probe' type?='type' name=ID '=' properties=Component
;

EffectorType returns Effector:
	'effector' type?='type' name=ID '=' body=EffectorBody
;

Effector returns Effector:
	'effector' name=ID ('->' superType=[Effector])? ('=' body=EffectorBody)
;

EffectorBody:
	'{'
	('model' ((modelName=ID '::' modeltype=ID) | ref=PropertyReference))?
	command=CommandCall
	(assignment+=Assignment)*
	'}'
;

Probe returns Probe:
	'probe' name=ID ('->' superType=[Probe])? ('=' properties=Component)?
;

GaugeType:
	'gauge' type?='type' name=ID '=' body=GaugeTypeBody
;

Gauge returns Gauge:
	'gauge' name=ID ('->' superType=[GaugeType])? /*('=' properties=Component)?*/ ('=' body=GaugeBody)?
;


GaugeBody:
	'{'
		'model' ((modelName=ID '::' modeltype=ID) | ref=PropertyReference) 
		(commands+=CommandCall)*
		(assignment+=Assignment)*
	'}'
;

GaugeTypeBody:
	'{'
	    (ModelFactory  mcf=(PropertyReference | Reference))?
	    (commands+=CommandReference)+
		(assignment+=Assignment)*
		
	'}'
;

JavaClassOrFactory:
	
	java=JavaReference | factory=PropertyReference
;


CommandReference:
	'command' name=ID '=' (regexp=StringLiteral '->' )? (target=ID'.')? command=ID '(' (formal+=[types::JvmType|FQN] (',' formal+=[types::JvmType|FQN])*)? ')'
;

CommandCall:
	'command' (name=ID '=')?  ((target=ID | ref=PropertyReference) '.')? command=ID '(' (actual+=Actual (',' actual+=Actual)*)? ')'
;

Actual:
	ref?='$<' (ng=ID | ag=INT) '>' |
	id=ID |
	pr=PropertyReference |
	value=StringLiteral |
	value=IntegerLiteral |
	value=BooleanLiteral |
	value=DoubleLiteral
;


enum ImportType:
	CONFIG='configuration' |
	PROPS='properties'  |
	STITCH="stitch" |
	ACME="acme" |
	FACTORY="factory"
;


Import:
//	'import' importedNamespace=ImportedFQN
'import' type=ImportType importURI=(RICH_TEXT_DQ) 
;

ImportedFQN:
	FQN ('.*')?
;

RootComponent returns Component:
	{Component} 
	   assignment+=Assignment*
	
;
Component returns Component:
	{Component} '{'
	assignment+=Assignment*
	'}'
;

Assignment:
	name=FQN  '=' value=Value
;

Value:
	value=Component |
	value=StringLiteral |
	value=BooleanLiteral |
	value=IntegerLiteral |
	value=DoubleLiteral |
	value=Reference |
	value=IPLiteral |
	value=LogLiteral |
	value=PropertyReference |
//	value=ModelMapping |
//	value=ProbeReference |
	value=Array // |
//	value=ModelFactoryReference

;

//ModelMapping:
//	mapping=AcmeMapping |
//	mapping=JavaMapping
//;
//
//enum MappingType:
//	EAVG='EAvg' |
//	AVG='Avg' |
//	MAX='Max' |
//	MIN='Min' |
//	EXPR='Expr'
//;
//	
//	
//
//AcmeMapping:
//	type=MappingType expr=(acme::booleanExpression  | acme::idExpression | acme::setExpression | acme::pathExpression)
//;


AnyRef:
	Factory | DeclaredProperty | Gauge | GaugeType | Probe | ProbeType | Effector | EffectorType 
;


Array:
	{Array} '[' (values+=Value (',' values+=Value)*)? ']'
;

LogLiteral:
	value=LOGLEVEL
;

enum LOGLEVEL:
	OFF | FATAL | ERROR | WARN | INFO | DEBUG | TRACE | ALL
;

IPLiteral:
	value=IPValue
;

IPValue returns ecore::EString:
	INT '.' INT '.' INT '.' INT
;

DoubleLiteral:
	value=DoubleValue
;

DoubleValue returns ecore::EDouble:
	IntValue '.' INT
;

IntegerLiteral:
	value=IntValue
;

IntValue returns ecore::EInt:
	('-' | '+')? INT
;

BooleanLiteral:
	{BooleanLiteral}(isTrue?='true'|'false')
;

Reference:
	(referable=[types::JvmType|FQN]) 
;

PropertyReference:
	'««' referable=[AnyRef|FQN] '»»'
;

//ProbeReference:
//	'probe' referable=[Probe|FQN]
//;
//
ModelFactoryReference:
	referable=[Factory|ID]
;
	
FQN:
	ID ('.' ID)*
;

StringLiteral:
//	SimpleStringLiteral | 
	RichStringDQ
;

//SimpleStringLiteral:
//	value=STRING
//;

//RichStringSQ:
//	{RichString} (
//		expressions+=RichStringLiteralSQ |
//		expressions+=RichStringLiteralStartSQ expressions+=RichStringPart?
//		(expressions+=RichStringLiteralInbetweenSQ expression+=RichStringPart?)*
//		expressions+=RichStringLiteralEndSQ
//	)
//;
//
//RichStringLiteralSQ:
//	{RichStringLiteral} value=RICH_TEXT_SQ 
//;
//
//RichStringLiteralStartSQ:
//	{RichStringLiteral}
//	value=RICH_TEXT_START_SQ
//;
//
//RichStringLiteralInbetweenSQ:
//	{RichStringLiteral}
//	(value=RICH_TEXT_INBETWEEN_SQ)
//;
//
//RichStringLiteralEndSQ:
//	{RichStringLiteral}
//	(value=RICH_TEXT_END_SQ)
//;

RichStringDQ:
	{RichString} (
		expressions+=RichStringLiteralDQ |
		expressions+=RichStringLiteralStartDQ expressions+=RichStringPart?
		(expressions+=RichStringLiteralInbetweenDQ expression+=RichStringPart?)*
		expressions+=RichStringLiteralEndDQ
	)
;

RichStringLiteralDQ:
	{RichStringLiteral} value=RICH_TEXT_DQ 
;

RichStringLiteralStartDQ:
	{RichStringLiteral}
	value=RICH_TEXT_START_DQ
;

RichStringLiteralInbetweenDQ:
	{RichStringLiteral}
	(value=RICH_TEXT_INBETWEEN_DQ)
;

RichStringLiteralEndDQ:
	{RichStringLiteral}
	(value=RICH_TEXT_END_DQ)
;

//InteralRichStringSQ:
//	{RichString} (
//		expressions+=RichStringLiteralInbetweenSQ (expressions+=RichStringPart? expressions+=RichStringLiteralInbetweenSQ)*
//	)
//;

RichStringPart:
	referable=[DeclaredProperty|FQN]
;

//
//PropertyRef:
//	referable=[Model|STRING]
//;
//
//PropertyReference:
//	value=PROPERTY_REFERENCE
//;

//StringLiteral hidden():
//	begin="'"
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end="'"
//	|
//	begin='"'
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end='"'
//;
//
//PropertyReference hidden():
//  '${' PropertyReferenceImpl '}';
//
////terminal PROPERTY_REFERENCE:
////	'${' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '}'
////;
//
//PropertyReferenceImpl returns PropertyReference hidden(WS,ML_COMMENT,SL_COMMENT):
//	referable=[DeclaredProperty|FQN]
//;
//
//PlainString:
//	value=ConstantValue
//;
//
//// To identify other keywords or INT as allowed parts in a string,
//// we use a customized lexer with predicates. 
//// This allows us to use e.g. single quotes without escape sequences
//// in double quoted strings and vice versa.
//ConstantValue:
//  (WS|
//  ANY_OTHER|
//  ID|
//  INT |
//  "target" | "var" | "probe" | "type"
////  "true" | 
////  "false" |
////  "target" | "setup" | "models" | "analysis" | "managers" | "executors" | "effector-managers" |
////  "system" | "properties" | "var" | "import" |
//  "." |
//  "\\'" | 
//  '\\"' | 
//  "\\${" | 
//  "\\\\")+;

terminal ID:
	('^')?('a'..'z' | 'A'..'Z') (('a'..'z' | 'A'..'Z') | '_' | '-' | '0'..'9')*
;

terminal INT returns ecore::EInt:
	('0'..'9')+
;

//terminal STRING returns ecore::EString:
//	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
//	"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
//;

//
//terminal RICH_TEXT : "'''" IN_RICH_STRING* ("'''"| ("'" "'"?)? EOF);
//terminal RICH_TEXT_START : "'''" IN_RICH_STRING* ("'" "'"?)? '«';
//terminal RICH_TEXT_END : '»' IN_RICH_STRING* ("'''"| ("'" "'"?)? EOF) ;
//terminal RICH_TEXT_INBETWEEN : '»' IN_RICH_STRING* ("'" "'"?)? '«';
//terminal COMMENT_RICH_TEXT_INBETWEEN: "««" !('\n'|'\r')* ('\r'? '\n' IN_RICH_STRING* ("'" "'"?)? '«')?;
//terminal COMMENT_RICH_TEXT_END: "««" !('\n'|'\r')* (('\r'? '\n' IN_RICH_STRING* ("'''"| ("'" "'"?)? EOF)) | EOF);
//
//terminal fragment IN_RICH_STRING :
//	  "''" !('«'|"'")
//	| "'" !('«'|"'")
//	| !('«'|"'");

//terminal RICH_TEXT_SQ returns ecore::EString:
//	"'" IN_RICH_STRING_SQ* "'"
//;
//
//terminal RICH_TEXT_START_SQ:
//	"'" IN_RICH_STRING_SQ* '«'
//;
//
//terminal RICH_TEXT_END_SQ:
//	'»' IN_RICH_STRING_SQ* "'"
//;
//
//terminal RICH_TEXT_INBETWEEN_SQ:
//	'»' IN_RICH_STRING_SQ* '«'
//;

terminal RICH_TEXT_DQ returns ecore::EString:
	'"' IN_RICH_STRING_DQ* '"'
;

terminal RICH_TEXT_START_DQ:
	'"' IN_RICH_STRING_DQ* '«'
;

terminal RICH_TEXT_END_DQ:
	'»' IN_RICH_STRING_DQ* '"'
;

terminal RICH_TEXT_INBETWEEN_DQ:
	'»' IN_RICH_STRING_DQ* '«'
;


//terminal RICH_TEXT : 
//	"'" IN_RICH_STRING_SQ* ("'"? EOF) |
//	'"' IN_RICH_STRING_DQ* ('"'? EOF)
//;
//
//terminal RICH_TEXT_START:
//	"'" IN_RICH_STRING_SQ* '«' |
//	'"' IN_RICH_STRING_DQ* '«'
//;
//
//terminal RICH_TEXT_END: 
//	'»' IN_RICH_STRING_SQ* ("'")? EOF |
//	'»' IN_RICH_STRING_DQ* ("'")? EOF
//	;
//
//terminal RICH_TEXT_INBETWEEN:
//	
//;
//terminal RICH_TEXT_START : "'''" IN_RICH_STRING* ("'" "'"?)? '«';
//terminal RICH_TEXT_END : '»' IN_RICH_STRING* ("'''"| ("'" "'"?)? EOF) ;
//terminal RICH_TEXT_INBETWEEN : '»' IN_RICH_STRING* ("'" "'"?)? '«';
//terminal COMMENT_RICH_TEXT_INBETWEEN: "««" !('\n'|'\r')* ('\r'? '\n' IN_RICH_STRING* ("'" "'"?)? '«')?;
//terminal COMMENT_RICH_TEXT_END: "««" !('\n'|'\r')* (('\r'? '\n' IN_RICH_STRING* ("'''"| ("'" "'"?)? EOF)) | EOF);

//terminal fragment IN_RICH_STRING_SQ :
//	  !('«'|"'"|"\n"|"\r");
	  
terminal fragment IN_RICH_STRING_DQ:
	!('«'|'"'|'»'|"\n"|"\r")
;




terminal ML_COMMENT:
  '/*'->'*/';

terminal SL_COMMENT:
  ('//' | '#') !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
  (' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
  .;



